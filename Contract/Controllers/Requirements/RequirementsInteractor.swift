//
//  RequirementsInteractor.swift
//  SmartContrakt
//
//  Created by Артем Валиев on 04/12/2018.
//  Copyright (c) 2018 Артем Валиев. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol RequirementsBusinessLogic
{
    var checkListId: String! { get }
    func loadRequirements(request: Requirements.Something.Request)
    func setRequirement(request: Requirements.SetRequirement.Request, cb: @escaping (RequirementModel?) -> Void)
    func reloadFromDB()
}

protocol RequirementsDataStore
{
  var checkListId: String! { get set }
}

class RequirementsInteractor: RequirementsBusinessLogic, RequirementsDataStore
{
    var checkListId: String!
    var presenter: RequirementsPresentationLogic?
  
    func loadRequirements(request: Requirements.Something.Request) {
        let localReq = getLocalRequirements()
        if localReq.count > 0 {
            Log("Есть локальные требования, показываем их", type: .info)
            show(requirements: localReq)
        } else {
            Log("Локальных требований нет, загружаем с сервера", type: .info)
            api.getRequirementsForCheckList(action: API.Action.getRequirementsForMy(checkListId: checkListId)) { [weak self] (result) in
                guard let sSelf = self else {
                    return
                }
                switch result {
                case .Success(let serverRequirements):
                    Log("Получили с сервера \(serverRequirements.count) требований", type: .info)
                    
                    let gr = DispatchGroup()
                    for serverRequirement in serverRequirements {
                        if let serverRequirId = serverRequirement.id {
                            gr.enter()
                            api.getPhotoLinksForRequirement(action: API.Action.getPhotoLinksForRequirement(id: serverRequirId), cb: { (result) in
                                gr.leave()
                            })
                        } else {
                            Log("No id for server requirement", type: .error)
                            assert(false)
                        }
                    }
                    
                    gr.notify(queue: .main, execute: { [weak self] in
                        guard let sSelf = self else { return }
                        sSelf.show(requirements: sSelf.getLocalRequirements())
                    })
                    
                case .Failure(let error):
                    Log(error.localizedDescription, type: .error)
                }
            }
        }

    }
    
    
    
    /// проверяем, есть ли требование на сервере, если есть то удаляем, потом создаем новое. Если на сервере такого нет, то просто создаем
    func setRequirement(request: Requirements.SetRequirement.Request, cb: @escaping (RequirementModel?) -> Void) {
        if let requirementId = request.requirementId {
            Log("going to update requirement with id: \(requirementId)", type: .info)
            // такое требование уже есть на сервере, вначале удалим его, чтобы не создавать дупликат
            Log("Удаляем требование с сервера", type: .info)
            deleteRequirement(request: Requirements.DeleteRequirement.Request(requirementId: requirementId)) { [weak self] (success) in
                if success {
                    Log("Удалили требование с сервера", type: .info)
                    self?.createRequirement(request: request, cb: cb)
                } else {
                    Log("Не удалось удалить требование с сервера", type: .error)
                    cb(nil)
                }
            }
        } else {
            Log("going to create new requirement on server", type: .info)
            createRequirement(request: request, cb: cb)
        }
    }
    
    
    
    
    
    /// создаем требование на сервере
    private func createRequirement(request: Requirements.SetRequirement.Request, cb: @escaping (RequirementModel?) -> Void) {
        Log("Создаем новое требование", type: .info)
        let action = API.Action.setRequirement(checkListId: checkListId,
                                               requirementText: request.requirementText,
                                               yesNo: request.yesNo,
                                               note: request.note ?? "")
        api.setRequirement(action: action) { (result) in
            switch result {
            case .Success(let serverRequirement):
                Log("Успешно создали требование на сервере", type: .info)
                cb(serverRequirement)
            case .Failure(let error):
                Log(error.localizedDescription, type: .error)
                cb(nil)
            }
        }
    }
    
    
    
    /// Удаляем требование на сервере (для того, чтобы обновить)
    private func deleteRequirement(request: Requirements.DeleteRequirement.Request, cb: @escaping (Bool) -> Void) {
        let action = API.Action.deleteRequirement(requirementId: request.requirementId)
        api.deleteRequirement(action: action) { (result) in
            switch result {
            case .Success(let success):
                cb(success)
            case .Failure(let error):
                Log(error.localizedDescription, type: .error)
                cb(false)
            }
        }
    }
    
    func reloadFromDB() {
        show(requirements: getLocalRequirements())
    }
    
    private func getLocalRequirements() -> [RequirementModel] {
        if let checklist: CheckListModel = getObjects(withId: checkListId).first {
            if let requirements: [RequirementModel] = checklist.requirements?.toArray() {
                return requirements.sorted(by: { ($0.title ?? "") < ($1.title ?? "") })
            } else {
                Log("No requirements for checklist", type: .warning)
                return []
            }
        } else {
            Log("local checklist not found", type: .error)
            assert(false)
        }
    }
    
    private func show(requirements: [RequirementModel]) {
        presenter?.presentRequirements(response: Requirements.Something.Response(requirements: requirements))
    }

}
